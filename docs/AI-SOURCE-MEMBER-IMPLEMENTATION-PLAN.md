# AI Source-Member Architecture: Implementation Plan

**Date:** 2025-10-01
**Type:** Break-and-Rebuild (Greenfield)
**Scope:** Complete terminology correction with no legacy stragglers
**Status:** Ready for Implementation

---

## Implementation Strategy

### Greenfield Principle: Break-and-Rebuild

**No Backward Compatibility Concerns:**
- This is framework v0.x - breaking changes acceptable
- Clean break establishes correct patterns from start
- Remove ALL legacy concepts completely
- Future-proof architecture for v1.0

**Core Mantra:** *"Leave no straggler code behind"*

---

## Phase 1: Create New Data Model (Foundation)

### 1.1 Create New Classes

**File:** `src/Koan.AI.Contracts/Sources/AiMemberDefinition.cs` (NEW)
```csharp
namespace Koan.AI.Contracts.Sources;

/// <summary>
/// Member: Individual endpoint within a source.
/// Examples: "ollama::host", "enterprise::ollama-1"
/// </summary>
public sealed class AiMemberDefinition
{
    /// <summary>
    /// Full member name: "source::member"
    /// </summary>
    public required string Name { get; init; }

    /// <summary>Parent source name</summary>
    public required string SourceName { get; init; }

    /// <summary>Connection string (URL)</summary>
    public required string ConnectionString { get; init; }

    /// <summary>
    /// Priority within source (host=100, linked=75, container=50)
    /// </summary>
    public int Priority { get; init; } = 50;

    /// <summary>
    /// Member-specific capabilities from discovery or config
    /// </summary>
    public Dictionary<string, AiCapabilityConfig> Capabilities { get; init; } = new();

    /// <summary>Origin: "auto-discovery (host)", "explicit-config"</summary>
    public string Origin { get; init; } = "";

    /// <summary>Health status from monitoring</summary>
    public HealthStatus? Health { get; set; }
}
```

**File:** Update `src/Koan.AI.Contracts/Sources/AiSourceDefinition.cs`
```csharp
namespace Koan.AI.Contracts.Sources;

/// <summary>
/// Source: Collection of members with policy.
/// Examples: "ollama" (auto), "enterprise" (named)
/// </summary>
public sealed class AiSourceDefinition
{
    /// <summary>Source name (used as member prefix)</summary>
    public required string Name { get; init; }

    /// <summary>Provider adapter ID (e.g., "ollama")</summary>
    public required string Provider { get; init; }

    /// <summary>
    /// Source priority: 100 (named), 50 (auto-generated)
    /// </summary>
    public int Priority { get; init; } = 50;

    /// <summary>
    /// Policy: "fallback", "round-robin", "weighted", "circuit-breaker"
    /// </summary>
    public string Policy { get; init; } = "fallback";

    /// <summary>Members in this source</summary>
    public List<AiMemberDefinition> Members { get; init; } = new();

    /// <summary>
    /// Aggregate capabilities
    /// Named: from config, Auto: union of members
    /// </summary>
    public Dictionary<string, AiCapabilityConfig> Capabilities { get; init; } = new();

    /// <summary>True if auto-discovered</summary>
    public bool IsAutoGenerated { get; init; }

    /// <summary>Origin: "auto-discovery", "explicit-config"</summary>
    public string Origin { get; init; } = "";

    /// <summary>Circuit breaker config</summary>
    public CircuitBreakerConfig? CircuitBreaker { get; init; }

    // REMOVED: Group property (sources ARE the groups)
    // REMOVED: ConnectionString (moved to members)
}
```

### 1.2 Update IAiSourceRegistry

**File:** `src/Koan.AI.Contracts/Sources/IAiSourceRegistry.cs`
```csharp
namespace Koan.AI.Contracts.Sources;

/// <summary>
/// Registry for AI sources (collections of members).
/// Sources contain members; no separate "group" concept.
/// </summary>
public interface IAiSourceRegistry
{
    /// <summary>Register or update source</summary>
    void RegisterSource(AiSourceDefinition source);

    /// <summary>Get source by name</summary>
    AiSourceDefinition? GetSource(string name);

    /// <summary>Check if source exists</summary>
    bool HasSource(string name);

    /// <summary>Get all sources</summary>
    IReadOnlyCollection<AiSourceDefinition> GetAllSources();

    /// <summary>Get sources by provider</summary>
    IReadOnlyCollection<AiSourceDefinition> GetSourcesForProvider(string provider);

    /// <summary>
    /// Add or update member in existing source
    /// Creates source if doesn't exist
    /// </summary>
    void AddOrUpdateMember(string sourceName, AiMemberDefinition member);

    /// <summary>Get member by full name (source::member)</summary>
    AiMemberDefinition? GetMember(string fullName);

    /// <summary>Remove source (and all its members)</summary>
    bool RemoveSource(string name);
}
```

### 1.3 Delete Obsolete Classes

**DELETE COMPLETELY:**
```
src/Koan.AI.Contracts/Sources/AiGroupDefinition.cs          ❌ DELETE
src/Koan.AI.Contracts/Sources/IAiGroupRegistry.cs           ❌ DELETE
src/Koan.AI/Sources/AiGroupRegistry.cs                       ❌ DELETE
```

**Verification:**
```bash
# After deletion, these should find nothing:
grep -r "AiGroupDefinition" src/
grep -r "IAiGroupRegistry" src/
grep -r "AiGroupRegistry" src/
```

---

## Phase 2: Update Source Registry Implementation

### 2.1 Rewrite AiSourceRegistry

**File:** `src/Koan.AI/Sources/AiSourceRegistry.cs`

```csharp
using System.Collections.Concurrent;
using Koan.AI.Contracts.Sources;

namespace Koan.AI.Sources;

public sealed class AiSourceRegistry : IAiSourceRegistry
{
    private readonly ConcurrentDictionary<string, AiSourceDefinition> _sources = new(StringComparer.OrdinalIgnoreCase);

    public void RegisterSource(AiSourceDefinition source)
    {
        if (string.IsNullOrWhiteSpace(source.Name))
            throw new ArgumentException("Source name cannot be empty", nameof(source));

        _sources[source.Name] = source;
    }

    public AiSourceDefinition? GetSource(string name)
        => _sources.TryGetValue(name, out var source) ? source : null;

    public bool HasSource(string name)
        => _sources.ContainsKey(name);

    public IReadOnlyCollection<AiSourceDefinition> GetAllSources()
        => _sources.Values.ToArray();

    public IReadOnlyCollection<AiSourceDefinition> GetSourcesForProvider(string provider)
        => _sources.Values
            .Where(s => string.Equals(s.Provider, provider, StringComparison.OrdinalIgnoreCase))
            .ToArray();

    public void AddOrUpdateMember(string sourceName, AiMemberDefinition member)
    {
        if (!_sources.TryGetValue(sourceName, out var source))
        {
            // Create new source with this member
            source = new AiSourceDefinition
            {
                Name = sourceName,
                Provider = member.SourceName, // Infer from member
                Members = new List<AiMemberDefinition> { member },
                IsAutoGenerated = true,
                Origin = "dynamic"
            };
            _sources[sourceName] = source;
            return;
        }

        // Update existing source
        var existingMember = source.Members.FirstOrDefault(m => m.Name == member.Name);
        if (existingMember != null)
        {
            source.Members.Remove(existingMember);
        }
        source.Members.Add(member);
    }

    public AiMemberDefinition? GetMember(string fullName)
    {
        // Parse "source::member"
        var parts = fullName.Split("::", StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2)
            return null;

        var sourceName = parts[0];
        if (!_sources.TryGetValue(sourceName, out var source))
            return null;

        return source.Members.FirstOrDefault(m => m.Name == fullName);
    }

    public bool RemoveSource(string name)
        => _sources.TryRemove(name, out _);

    /// <summary>
    /// Discover sources from configuration.
    /// NO LONGER creates "Default" source - each provider registers its own.
    /// </summary>
    public void DiscoverFromConfiguration(IConfiguration config, ILogger? logger = null)
    {
        var sourcesSection = config.GetSection("Koan:Ai:Sources");

        foreach (var sourceConfig in sourcesSection.GetChildren())
        {
            var sourceName = sourceConfig.Key;
            var provider = sourceConfig["Provider"];

            if (string.IsNullOrWhiteSpace(provider))
            {
                logger?.LogWarning("Source '{SourceName}' has no provider, skipping", sourceName);
                continue;
            }

            var priority = sourceConfig.GetValue<int?>("Priority") ?? 100; // Named sources default to 100
            var policy = sourceConfig.GetValue<string?>("Policy") ?? "fallback";

            // Parse members
            var members = ParseMembers(sourceConfig.GetSection("Members"), sourceName, logger);

            // Parse capabilities
            var capabilities = ParseCapabilities(sourceConfig.GetSection("Capabilities"), logger);

            RegisterSource(new AiSourceDefinition
            {
                Name = sourceName,
                Provider = provider,
                Priority = priority,
                Policy = policy,
                Members = members,
                Capabilities = capabilities,
                IsAutoGenerated = false,
                Origin = "explicit-config"
            });

            logger?.LogInformation(
                "Registered source '{SourceName}' with provider '{Provider}' and {MemberCount} members",
                sourceName, provider, members.Count);
        }
    }

    private List<AiMemberDefinition> ParseMembers(
        IConfigurationSection membersSection,
        string sourceName,
        ILogger? logger)
    {
        var members = new List<AiMemberDefinition>();

        foreach (var memberConfig in membersSection.GetChildren())
        {
            var memberName = memberConfig["Name"];
            var connectionString = memberConfig["ConnectionString"];

            if (string.IsNullOrWhiteSpace(connectionString))
            {
                logger?.LogWarning("Member in source '{SourceName}' has no ConnectionString, skipping", sourceName);
                continue;
            }

            // Ensure name follows pattern
            if (string.IsNullOrWhiteSpace(memberName))
            {
                memberName = $"{sourceName}::member-{members.Count + 1}";
            }
            else if (!memberName.Contains("::"))
            {
                memberName = $"{sourceName}::{memberName}";
            }

            var priority = memberConfig.GetValue<int?>("Priority") ?? 50;
            var capabilities = ParseCapabilities(memberConfig.GetSection("Capabilities"), logger);

            members.Add(new AiMemberDefinition
            {
                Name = memberName,
                SourceName = sourceName,
                ConnectionString = connectionString,
                Priority = priority,
                Capabilities = capabilities,
                Origin = "explicit-config"
            });
        }

        return members;
    }

    private Dictionary<string, AiCapabilityConfig> ParseCapabilities(
        IConfigurationSection capabilitiesSection,
        ILogger? logger)
    {
        var capabilities = new Dictionary<string, AiCapabilityConfig>(StringComparer.OrdinalIgnoreCase);

        foreach (var capConfig in capabilitiesSection.GetChildren())
        {
            var capabilityName = capConfig.Key;
            var model = capConfig["Model"];

            if (string.IsNullOrWhiteSpace(model))
            {
                logger?.LogWarning("Capability '{Capability}' has no model, skipping", capabilityName);
                continue;
            }

            capabilities[capabilityName] = new AiCapabilityConfig
            {
                Model = model,
                AutoDownload = capConfig.GetValue<bool?>("AutoDownload") ?? true
            };
        }

        return capabilities;
    }
}
```

### 2.2 Update Service Registration

**File:** `src/Koan.AI/ServiceCollectionExtensions.cs`

```csharp
public static IServiceCollection AddAi(this IServiceCollection services, IConfiguration? config = null)
{
    // Register options
    if (config is not null)
    {
        services.AddKoanOptions<AiOptions>(config, "Koan:Ai");
    }
    else
    {
        services.AddKoanOptions<AiOptions>("Koan:Ai");
    }

    // Register source registry (replaces both old source + group registries)
    services.TryAddSingleton<IAiSourceRegistry>(sp =>
    {
        var registry = new AiSourceRegistry();
        var configuration = sp.GetRequiredService<IConfiguration>();
        var logger = sp.GetService<ILogger<AiSourceRegistry>>();
        registry.DiscoverFromConfiguration(configuration, logger);
        return registry;
    });

    // REMOVED: IAiGroupRegistry registration (no longer exists)

    // Register health monitoring (operates on sources now, not groups)
    services.TryAddSingleton<ISourceHealthRegistry>(sp =>
    {
        var healthRegistry = new SourceHealthRegistry(sp.GetService<ILogger<SourceHealthRegistry>>());
        var sourceRegistry = sp.GetRequiredService<IAiSourceRegistry>();

        foreach (var source in sourceRegistry.GetAllSources())
        {
            // Register health monitoring for each source
            healthRegistry.RegisterSource(source.Name, source.CircuitBreaker);
        }

        return healthRegistry;
    });

    // Rest unchanged
    services.AddHostedService<AiSourceHealthMonitor>();
    services.TryAddSingleton<IAiAdapterRegistry, InMemoryAdapterRegistry>();
    services.TryAddSingleton<IAiRouter, DefaultAiRouter>();
    services.TryAddSingleton<IAi, RouterAi>();

    return services;
}
```

---

## Phase 3: Update Ollama Discovery Service

### 3.1 Rewrite Discovery Logic

**File:** `src/Connectors/AI/Ollama/Initialization/OllamaDiscoveryService.cs`

**Key Changes:**
1. Create source named "ollama" (not "ollama-auto")
2. Members named "ollama::host", "ollama::container" (not "ollama-auto-host")
3. Register source with members, not individual "sources"

```csharp
private async Task DiscoverAndRegisterMembers(string? defaultModel, CancellationToken cancellationToken)
{
    var discoveredMembers = new List<(string Name, string Url, int Priority, string Origin)>();

    // Probe candidates
    var candidates = new[]
    {
        (Name: "host", Url: "http://host.docker.internal:11434", Priority: 100, Origin: "host"),
        (Name: "container", Url: "http://ollama:11434", Priority: 50, Origin: "container"),
        (Name: "linked", Url: "http://localhost:11434", Priority: 75, Origin: "linked")
    };

    var discoveryTasks = candidates.Select(async candidate =>
    {
        try
        {
            using var httpClient = new HttpClient { Timeout = TimeSpan.FromMilliseconds(500) };
            var response = await httpClient.GetAsync($"{candidate.Url}/api/tags", cancellationToken);

            if (response.IsSuccessStatusCode)
            {
                KoanLog.BootDebug(_logger, LogActions.Discovery, "candidate-success",
                    ("name", candidate.Name),
                    ("url", candidate.Url));
                return candidate;
            }
        }
        catch (Exception ex)
        {
            KoanLog.BootDebug(_logger, LogActions.Discovery, "candidate-failed",
                ("name", candidate.Name),
                ("reason", ex.Message));
        }

        return default;
    }).ToList();

    var results = await Task.WhenAll(discoveryTasks);
    discoveredMembers.AddRange(results.Where(r => r != default));

    if (discoveredMembers.Count == 0)
    {
        KoanLog.BootWarning(_logger, LogActions.Discovery, "no-members-found",
            ("reason", "all-candidates-failed"));
        return;
    }

    KoanLog.BootInfo(_logger, LogActions.Discovery, "members-found",
        ("count", discoveredMembers.Count));

    // Create members with capability introspection
    var members = new List<AiMemberDefinition>();

    foreach (var (name, url, priority, origin) in discoveredMembers.OrderByDescending(s => s.Priority))
    {
        try
        {
            // Introspect capabilities
            var capabilities = await IntrospectCapabilities(url, defaultModel, cancellationToken);

            var memberName = $"ollama::{name}"; // NEW PATTERN
            var member = new AiMemberDefinition
            {
                Name = memberName,
                SourceName = "ollama",
                ConnectionString = url,
                Priority = priority,
                Capabilities = capabilities,
                Origin = $"auto-discovery ({origin})"
            };

            members.Add(member);

            var capabilityList = string.Join(", ", capabilities.Select(kv => $"{kv.Key}:{kv.Value.Model}"));
            KoanLog.BootInfo(_logger, LogActions.Discovery, "member-registered",
                ("name", memberName),
                ("url", url),
                ("priority", priority),
                ("capabilities", capabilities.Count),
                ("details", capabilityList));
        }
        catch (Exception ex)
        {
            KoanLog.BootWarning(_logger, LogActions.Discovery, "member-registration-failed",
                ("name", name),
                ("reason", ex.Message));
        }
    }

    // Create "ollama" source containing all members
    var ollamaSource = new AiSourceDefinition
    {
        Name = "ollama",
        Provider = "ollama",
        Priority = 50, // Auto-generated default
        Policy = "fallback",
        Members = members,
        Capabilities = MergeCapabilities(members),
        IsAutoGenerated = true,
        Origin = "auto-discovery"
    };

    _sourceRegistry!.RegisterSource(ollamaSource);

    KoanLog.BootInfo(_logger, LogActions.Discovery, "source-registered",
        ("name", "ollama"),
        ("members", members.Count),
        ("policy", "fallback"));

    // Register ONE adapter instance for highest-priority member
    if (members.Count > 0)
    {
        var primaryMember = members.OrderByDescending(m => m.Priority).First();
        await RegisterOllamaAdapter(primaryMember.ConnectionString, defaultModel, cancellationToken);
    }
}

private Dictionary<string, AiCapabilityConfig> MergeCapabilities(List<AiMemberDefinition> members)
{
    // Union of all member capabilities
    var merged = new Dictionary<string, AiCapabilityConfig>(StringComparer.OrdinalIgnoreCase);

    foreach (var member in members)
    {
        foreach (var (capability, config) in member.Capabilities)
        {
            if (!merged.ContainsKey(capability))
            {
                merged[capability] = config;
            }
        }
    }

    return merged;
}
```

---

## Phase 4: Update Router

### 4.1 Remove Group Logic

**File:** `src/Koan.AI/DefaultAiRouter.cs`

**Delete methods:**
- `GetOrCreateGroupAdapter()` ❌
- All group-related logic ❌

**Update `ResolveAdapterForCapability()`:**

```csharp
private (IAiAdapter? Adapter, string? Model, AiMemberDefinition? Member) ResolveAdapterForCapability(
    string capabilityName,
    string? explicitModel,
    string? sourceName,
    string? memberName)
{
    if (_sourceRegistry == null)
        return (null, null, null);

    if (!string.IsNullOrWhiteSpace(explicitModel))
        return (null, null, null);

    // 1. Resolve source (default to provider for capability)
    var source = ResolveSource(sourceName, capabilityName);
    if (source == null)
    {
        _logger?.LogDebug("No source found for capability '{Capability}'", capabilityName);
        return (null, null, null);
    }

    // 2. Select member within source (explicit or policy-based)
    var member = SelectMember(source, memberName, capabilityName);
    if (member == null)
    {
        _logger?.LogWarning("No member found in source '{SourceName}' for capability '{Capability}'",
            source.Name, capabilityName);
        return (null, null, null);
    }

    // 3. Get adapter by provider
    var adapter = _registry.Get(source.Provider);
    if (adapter == null)
    {
        _logger?.LogWarning("No adapter found for provider '{Provider}' (source: '{SourceName}')",
            source.Provider, source.Name);
        return (null, null, null);
    }

    // 4. Get model from member or source capabilities
    var model = member.Capabilities.TryGetValue(capabilityName, out var capConfig)
        ? capConfig.Model
        : source.Capabilities.TryGetValue(capabilityName, out capConfig)
            ? capConfig.Model
            : null;

    _logger?.LogDebug(
        "Resolved: capability '{Capability}' → source '{SourceName}' → member '{MemberName}' → adapter '{AdapterId}' → model '{Model}'",
        capabilityName, source.Name, member.Name, adapter.Id, model);

    return (adapter, model, member);
}

private AiSourceDefinition? ResolveSource(string? sourceName, string capabilityName)
{
    // Explicit source specified
    if (!string.IsNullOrWhiteSpace(sourceName))
    {
        return _sourceRegistry!.GetSource(sourceName);
    }

    // Default: find highest-priority source with this capability
    var sources = _sourceRegistry!.GetAllSources()
        .Where(s => s.Capabilities.ContainsKey(capabilityName) ||
                   s.Members.Any(m => m.Capabilities.ContainsKey(capabilityName)))
        .OrderByDescending(s => s.Priority)
        .ToList();

    return sources.FirstOrDefault();
}

private AiMemberDefinition? SelectMember(
    AiSourceDefinition source,
    string? memberName,
    string capabilityName)
{
    // Explicit member specified
    if (!string.IsNullOrWhiteSpace(memberName))
    {
        var explicitMember = source.Members.FirstOrDefault(m => m.Name == memberName);
        if (explicitMember != null)
            return explicitMember;

        _logger?.LogWarning("Member '{MemberName}' not found in source '{SourceName}'",
            memberName, source.Name);
    }

    // Apply source policy to select member
    return ApplyPolicy(source, capabilityName);
}

private AiMemberDefinition? ApplyPolicy(AiSourceDefinition source, string capabilityName)
{
    // Filter members with this capability
    var eligibleMembers = source.Members
        .Where(m => m.Capabilities.ContainsKey(capabilityName))
        .ToList();

    if (eligibleMembers.Count == 0)
    {
        // Fallback: any healthy member
        eligibleMembers = source.Members
            .Where(m => m.Health?.IsHealthy != false)
            .ToList();
    }

    if (eligibleMembers.Count == 0)
        return null;

    return source.Policy.ToLowerInvariant() switch
    {
        "round-robin" => RoundRobinSelect(eligibleMembers),
        "weighted" => WeightedSelect(eligibleMembers),
        _ => FallbackSelect(eligibleMembers)
    };
}

private AiMemberDefinition FallbackSelect(List<AiMemberDefinition> members)
{
    return members
        .OrderByDescending(m => m.Priority)
        .ThenBy(m => m.Health?.IsHealthy == false ? 1 : 0)
        .First();
}
```

---

## Phase 5: Update Adapter

### 5.1 Update OllamaAdapter to Use Members

**File:** `src/Connectors/AI/Ollama/OllamaAdapter.cs`

**Update `EmbedAsync()` and `ChatAsync()`:**

```csharp
public async Task<AiEmbeddingsResponse> EmbedAsync(
    AiEmbeddingsRequest request,
    CancellationToken ct = default)
    => await this.WithReadinessAsync(async () =>
    {
        // Resolve member from request context
        var memberName = request.Route?.MemberName;
        var member = ResolveMember(memberName);

        // Get HttpClient for this member
        var client = GetClientForMember(member);

        // Use model from request or member capabilities
        var model = request.Model
            ?? (member.Capabilities.TryGetValue("Embedding", out var cap) ? cap.Model : null)
            ?? _defaultModel;

        if (string.IsNullOrWhiteSpace(model))
        {
            throw new InvalidOperationException("Ollama adapter requires a model name.");
        }

        var vectors = new List<float[]>();
        foreach (var input in request.Input)
        {
            var body = new { model, prompt = input };
            var payload = JsonConvert.SerializeObject(body);

            using var resp = await client.PostAsync("/api/embeddings",
                new StringContent(payload, Encoding.UTF8, "application/json"), ct);

            if (!resp.IsSuccessStatusCode)
            {
                var text = await resp.Content.ReadAsStringAsync(ct);
                Logger.LogWarning("Ollama: embeddings failed ({Status}) body={Body}",
                    (int)resp.StatusCode, text);
            }

            resp.EnsureSuccessStatusCode();
            var json = await resp.Content.ReadAsStringAsync(ct);
            var doc = JsonConvert.DeserializeObject<OllamaEmbeddingsResponse>(json)
                ?? throw new InvalidOperationException("Empty response from Ollama.");

            vectors.Add(doc.embedding ?? Array.Empty<float>());
        }

        var dimension = vectors.FirstOrDefault()?.Length ?? 0;
        var usage = new AiUsage { TotalTokens = vectors.Count };

        return new AiEmbeddingsResponse
        {
            Data = vectors.Select((v, i) => new AiEmbedding
            {
                Embedding = v,
                Index = i
            }).ToArray(),
            Model = model,
            Usage = usage
        };
    }, ct);

private AiMemberDefinition ResolveMember(string? memberName)
{
    if (_sourceRegistry == null)
    {
        // Fallback: use primary client
        return new AiMemberDefinition
        {
            Name = AdapterId,
            SourceName = AdapterId,
            ConnectionString = _http.BaseAddress?.ToString() ?? "",
            Capabilities = new Dictionary<string, AiCapabilityConfig>()
        };
    }

    // Default to "ollama" source if no member specified
    memberName ??= AdapterId;

    // Parse member name: "source::member" or just "source"
    var parts = memberName.Split("::");
    var sourceName = parts[0];

    var source = _sourceRegistry.GetSource(sourceName);
    if (source == null)
    {
        Logger.LogWarning("Source '{SourceName}' not found, using primary client", sourceName);
        return CreateFallbackMember();
    }

    // Explicit member
    if (parts.Length > 1)
    {
        var member = source.Members.FirstOrDefault(m => m.Name == memberName);
        if (member != null)
            return member;

        Logger.LogWarning("Member '{MemberName}' not found in source '{SourceName}', using fallback",
            memberName, sourceName);
    }

    // Apply policy to select member
    return ApplyPolicyToSelectMember(source, "Embedding");
}

private AiMemberDefinition ApplyPolicyToSelectMember(AiSourceDefinition source, string capability)
{
    var eligibleMembers = source.Members
        .Where(m => m.Capabilities.ContainsKey(capability))
        .OrderByDescending(m => m.Priority)
        .ToList();

    if (eligibleMembers.Count == 0)
        eligibleMembers = source.Members.OrderByDescending(m => m.Priority).ToList();

    return eligibleMembers.FirstOrDefault() ?? CreateFallbackMember();
}

private HttpClient GetClientForMember(AiMemberDefinition member)
{
    return _clientPool.GetOrAdd(member.ConnectionString, url =>
    {
        Logger.LogDebug("Creating HttpClient for member '{MemberName}' at '{Url}'",
            member.Name, url);

        return new HttpClient
        {
            BaseAddress = new Uri(url),
            Timeout = TimeSpan.FromSeconds(60)
        };
    });
}

private AiMemberDefinition CreateFallbackMember()
{
    return new AiMemberDefinition
    {
        Name = AdapterId,
        SourceName = AdapterId,
        ConnectionString = _http.BaseAddress?.ToString() ?? "http://localhost:11434",
        Priority = 50,
        Capabilities = new Dictionary<string, AiCapabilityConfig>()
    };
}
```

---

## Phase 6: Update Request/Route Models

### 6.1 Add MemberName to AiRoute

**File:** `src/Koan.AI.Contracts/Models/AiRoute.cs`

```csharp
namespace Koan.AI.Contracts.Models;

/// <summary>
/// Routing information for AI requests
/// </summary>
public record AiRoute
{
    /// <summary>
    /// Source name (e.g., "ollama", "enterprise")
    /// If null, uses default source for capability
    /// </summary>
    public string? SourceName { get; init; }

    /// <summary>
    /// Explicit member name (e.g., "ollama::host", "enterprise::ollama-1")
    /// If null, source policy selects member
    /// </summary>
    public string? MemberName { get; init; }

    /// <summary>
    /// DEPRECATED: Use SourceName instead
    /// Kept for backward compatibility
    /// </summary>
    [Obsolete("Use SourceName instead")]
    public string? AdapterId { get; init; }

    /// <summary>
    /// Policy override: "fallback", "round-robin", "weighted"
    /// Overrides source's default policy
    /// </summary>
    public string? Policy { get; init; }
}
```

---

## Phase 7: Update Configuration Examples

### 7.1 Update Sample appsettings.json

**File:** `samples/S5.Recs/appsettings.json`

```json
{
  "Koan": {
    "Ai": {
      "AutoDiscoveryEnabled": true,
      "Sources": {
        "enterprise": {
          "Provider": "ollama",
          "Priority": 100,
          "Policy": "fallback",
          "CircuitBreaker": {
            "FailureThreshold": 5,
            "SuccessThreshold": 2,
            "Timeout": "00:00:30"
          },
          "Members": [
            {
              "Name": "enterprise::primary",
              "ConnectionString": "http://prod-ollama:11434",
              "Priority": 100,
              "Capabilities": {
                "Chat": { "Model": "llama3.1:8b" },
                "Embedding": { "Model": "all-minilm:latest" }
              }
            },
            {
              "Name": "enterprise::backup",
              "ConnectionString": "http://backup-ollama:11434",
              "Priority": 50
            }
          ]
        }
      }
    }
  }
}
```

---

## Phase 8: Testing & Verification

### 8.1 Unit Tests

**File:** `tests/Koan.AI.Tests/Sources/AiSourceRegistryTests.cs` (NEW)

```csharp
public class AiSourceRegistryTests
{
    [Fact]
    public void RegisterSource_WithMembers_StoresCorrectly()
    {
        var registry = new AiSourceRegistry();

        var source = new AiSourceDefinition
        {
            Name = "test-source",
            Provider = "ollama",
            Members = new List<AiMemberDefinition>
            {
                new() { Name = "test-source::member1", SourceName = "test-source", ConnectionString = "http://host1", Priority = 100 },
                new() { Name = "test-source::member2", SourceName = "test-source", ConnectionString = "http://host2", Priority = 50 }
            }
        };

        registry.RegisterSource(source);

        var retrieved = registry.GetSource("test-source");
        Assert.NotNull(retrieved);
        Assert.Equal(2, retrieved.Members.Count);
        Assert.Equal("test-source::member1", retrieved.Members[0].Name);
    }

    [Fact]
    public void GetMember_WithValidName_ReturnsCorrectMember()
    {
        var registry = new AiSourceRegistry();
        registry.RegisterSource(new AiSourceDefinition
        {
            Name = "ollama",
            Provider = "ollama",
            Members = new List<AiMemberDefinition>
            {
                new() { Name = "ollama::host", SourceName = "ollama", ConnectionString = "http://host" }
            }
        });

        var member = registry.GetMember("ollama::host");

        Assert.NotNull(member);
        Assert.Equal("http://host", member.ConnectionString);
    }

    [Fact]
    public void MemberName_FollowsPattern()
    {
        var member = new AiMemberDefinition
        {
            Name = "enterprise::ollama-1",
            SourceName = "enterprise",
            ConnectionString = "http://prod"
        };

        Assert.Contains("::", member.Name);
        Assert.StartsWith("enterprise", member.Name);
    }
}
```

### 8.2 Integration Tests

**File:** `tests/Koan.AI.Tests/Integration/OllamaDiscoveryTests.cs`

```csharp
public class OllamaDiscoveryTests : IClassFixture<OllamaTestFixture>
{
    [Fact]
    public async Task Discovery_CreatesSourceWithMembers()
    {
        var services = new ServiceCollection();
        services.AddLogging();
        services.AddAi();
        var sp = services.BuildServiceProvider();

        var registry = sp.GetRequiredService<IAiSourceRegistry>();
        await Task.Delay(2000); // Wait for discovery

        var source = registry.GetSource("ollama");
        Assert.NotNull(source);
        Assert.True(source.Members.Count > 0);
        Assert.All(source.Members, m => Assert.Contains("::", m.Name));
    }

    [Fact]
    public async Task Router_SelectsHighestPriorityMember()
    {
        // Setup source with multiple members
        var registry = new AiSourceRegistry();
        registry.RegisterSource(new AiSourceDefinition
        {
            Name = "ollama",
            Provider = "ollama",
            Policy = "fallback",
            Members = new List<AiMemberDefinition>
            {
                new() { Name = "ollama::container", Priority = 50, Capabilities = new() { ["Embedding"] = new() { Model = "all-minilm" } } },
                new() { Name = "ollama::host", Priority = 100, Capabilities = new() { ["Embedding"] = new() { Model = "all-minilm" } } }
            }
        });

        // Router should select ollama::host (priority=100)
        var source = registry.GetSource("ollama");
        var member = source.Members.OrderByDescending(m => m.Priority).First();

        Assert.Equal("ollama::host", member.Name);
    }
}
```

---

## Phase 9: Documentation Updates

### 9.1 Update README.md Examples

**File:** `src/Koan.AI/README.md`

```markdown
# Koan.AI

## Quick Start

### Zero Configuration (Auto-Discovery)

```csharp
// Just reference the package
services.AddKoan();

// Use capabilities
var response = await Ai.Embed("some text");
// Auto-discovers Ollama, creates "ollama" source with members
```

### Named Sources

```json
{
  "Koan:Ai:Sources": {
    "enterprise": {
      "Provider": "ollama",
      "Priority": 100,
      "Policy": "fallback",
      "Members": [
        {
          "Name": "enterprise::primary",
          "ConnectionString": "http://prod-ollama:11434"
        }
      ]
    }
  }
}
```

### Explicit Member Selection

```csharp
// Use specific member
await Ai.Embed("text", new AiEmbeddingsRequest
{
    Route = new AiRoute
    {
        MemberName = "enterprise::backup"
    }
});
```

## Architecture

### Source-Member Hierarchy

- **Source**: Collection of endpoints (e.g., "ollama", "enterprise")
- **Member**: Individual endpoint (e.g., "ollama::host")
- **Policy**: Selection strategy (fallback, round-robin, weighted)

See [AI-SOURCE-MEMBER-ARCHITECTURE.md](../../docs/AI-SOURCE-MEMBER-ARCHITECTURE.md) for details.
```

---

## Phase 10: Migration Guide

### 10.1 Create Migration Document

**File:** `docs/MIGRATION-SOURCE-MEMBER.md`

```markdown
# Migration Guide: Source-Member Architecture

## Breaking Changes

### Deleted Concepts
- `IAiGroupRegistry` → No longer exists
- `AiGroupDefinition` → No longer exists
- "Groups" → Now called "Sources"

### Renamed Concepts
- Old "Source" → Now "Member"
- Old "Group" → Now "Source"
- "ollama-auto-host" → "ollama::host"

### Configuration Changes

**Before:**
```json
{
  "Koan:Ai:Groups": { "ollama-auto": { "Policy": "fallback" } },
  "Koan:Ai:Sources": {
    "ollama-auto-host": { "ConnectionString": "..." }
  }
}
```

**After:**
```json
{
  "Koan:Ai:Sources": {
    "ollama": {
      "Policy": "fallback",
      "Members": [
        { "Name": "ollama::host", "ConnectionString": "..." }
      ]
    }
  }
}
```

## Upgrade Path

1. Update package references
2. Remove references to `IAiGroupRegistry`
3. Update configuration files to new format
4. Replace member names: "provider-auto-location" → "provider::location"
5. Use `SourceName` instead of `AdapterId` in routes

## No Backward Compatibility

This is v0.x - breaking changes expected. Clean migration required.
```

---

## Implementation Checklist

### Phase 1: Foundation ✅
- [ ] Create `AiMemberDefinition.cs`
- [ ] Update `AiSourceDefinition.cs` (remove Group, add Members)
- [ ] Update `IAiSourceRegistry` interface
- [ ] Delete `IAiGroupRegistry.cs`
- [ ] Delete `AiGroupDefinition.cs`
- [ ] Delete `AiGroupRegistry.cs`

### Phase 2: Registry ✅
- [ ] Rewrite `AiSourceRegistry` implementation
- [ ] Update `ServiceCollectionExtensions.cs`
- [ ] Remove group registry registration

### Phase 3: Discovery ✅
- [ ] Update `OllamaDiscoveryService` naming pattern
- [ ] Change "ollama-auto-X" → "ollama::X"
- [ ] Create source with members instead of individual sources

### Phase 4: Router ✅
- [ ] Remove group-related methods from `DefaultAiRouter`
- [ ] Update `ResolveAdapterForCapability()` to use members
- [ ] Implement policy-based member selection

### Phase 5: Adapter ✅
- [ ] Update `OllamaAdapter` to resolve members
- [ ] Implement `GetClientForMember()`
- [ ] Add policy selection logic

### Phase 6: Models ✅
- [ ] Add `MemberName` to `AiRoute`
- [ ] Deprecate `AdapterId` with obsolete attribute

### Phase 7: Configuration ✅
- [ ] Update sample appsettings.json files
- [ ] Document new configuration format

### Phase 8: Tests ✅
- [ ] Write unit tests for registry
- [ ] Write integration tests for discovery
- [ ] Write end-to-end tests for routing

### Phase 9: Documentation ✅
- [ ] Update README.md
- [ ] Create architecture document (done: AI-SOURCE-MEMBER-ARCHITECTURE.md)
- [ ] Update ADR-0014 with amendment (done)

### Phase 10: Migration ✅
- [ ] Create migration guide
- [ ] Update changelog
- [ ] Tag breaking change release

---

## Success Criteria

✅ **No Legacy Code:**
- Zero references to "Group" in production code
- Zero references to old naming pattern "provider-auto-location"
- All uses of "Source" refer to collections, not endpoints

✅ **Correct Naming:**
- All members follow `source::member` pattern
- Default source = provider name
- No "Default" source with empty provider

✅ **Tests Pass:**
- All unit tests green
- All integration tests green
- Manual testing confirms behavior

✅ **Documentation Complete:**
- README updated with examples
- Architecture document canonical
- Migration guide comprehensive

---

## Timeline Estimate

- **Phase 1-2 (Foundation + Registry):** 4 hours
- **Phase 3 (Discovery):** 3 hours
- **Phase 4-5 (Router + Adapter):** 5 hours
- **Phase 6-7 (Models + Config):** 2 hours
- **Phase 8 (Tests):** 4 hours
- **Phase 9-10 (Docs + Migration):** 3 hours

**Total:** ~21 hours (3 development days)

---

## Next Steps

1. Review and approve this plan
2. Create feature branch: `feature/source-member-architecture`
3. Implement phases 1-10 in order
4. Review and test each phase
5. Merge to dev branch
6. Tag breaking change release

**Ready for implementation - awaiting approval to proceed.**
